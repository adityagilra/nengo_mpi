import nengo
from nengo.connection import Connection
from nengo.ensemble import Ensemble
from nengo.node import Node
from nengo.probe import Probe
from nengo import builder
from nengo.simulator import ProbeDict
import nengo.utils.numpy as npext
from nengo.cache import NoDecoderCache, get_default_decoder_cache

import mpi_sim
import chunk
from partition import Partitioner

import numpy as np
from collections import defaultdict

import warnings

import logging
logger = logging.getLogger(__name__)

nengo.log(debug=False, path=None)


def make_builder(base):
    """
    Create a version of an existing builder function whose only difference
    is that it assumes the model is an instance of MpiModel, and uses that
    model to record which ops are built as part of building which high-level
    objects.

    Parameters
    ----------
    base: The existing builder function that we want to augment.

    """

    def build_object(model, obj):
        try:
            model.push_object(obj)
        except AttributeError:
            raise ValueError(
                "Must use an instance of MpiModel.")

        base(model, obj)
        model.pop_object(obj)

    build_object.__doc__ = (
        "Builder function augmented to make use "
        "of MpiModels.\n\n" + str(base.__doc__))

    return build_object


# Overwrite some of the default builder functions with functions that keep
# track of the operators that are created as part of building the objects, and
# store that information in a dictionary in the MpiModel. This information
# is used to assign operators to the correct components.
with warnings.catch_warnings():

    # Ignore the warning generated by overwriting the builder functions.
    warnings.simplefilter('ignore')

    builder.Builder.register(Ensemble)(
        make_builder(builder.build_ensemble))

    builder.Builder.register(Node)(
        make_builder(builder.build_node))

    builder.Builder.register(Connection)(
        make_builder(builder.build_connection))

    builder.Builder.register(Probe)(
        make_builder(builder.build_probe))


class MpiModel(builder.Model):
    """
    Output of the Builder, used by the Simulator.

    Differs from the Model in the reference implementation in that
    as the model is built, it keeps track of the object currently being
    built. This permits it to track which operators are added as part
    of which high-level objects, so that those operators can later be
    added to the correct MPI component (required since MPI components are
    specified in terms of the high-level nengo objects like nodes,
    networks and ensembles).
    """

    def __init__(
            self, dt=0.001, label=None, decoder_cache=NoDecoderCache()):

        self._object_context = [None]
        self.object_ops = defaultdict(list)
        super(MpiModel, self).__init__(dt, label, decoder_cache)

    def __str__(self):
        return "MpiModel: %s" % self.label

    def push_object(self, object):
        self._object_context.append(object)

    def pop_object(self, object):
        self._object_context.pop()

    def add_op(self, op):
        """
        Records that the operator was added as part of building
        the object that is on the top of _object_context stack,
        and then uses refimpl add_op to finish adding the op.
        """
        self.object_ops[self._object_context[-1]].append(op)
        super(MpiModel, self).add_op(op)

    def from_refimpl_model(self, model):
        """Create an MpiModel from an instance of a refimpl Model."""

        if not isinstance(model, builder.Model):
            raise TypeError(
                "Model must be an instance of "
                "%s." % builder.model.__name__)

        self.dt = model.dt
        self.label = model.label
        self.decoder_cache = model.decoder_cache

        self.toplevel = model.toplevel
        self.config = model.config

        self.operators = model.operators
        self.params = model.params
        self.seeds = model.seeds
        self.probes = model.probes
        self.sig = model.sig


class Simulator(object):
    """MPI simulator for nengo 2.0."""

    def __init__(
            self, network, dt=0.001, seed=None, model=None,
            partitioner=None):
        """
        Most of the time, you will pass in a network and sometimes a dt::

            sim1 = nengo.Simulator(my_network)  # Uses default 0.001s dt
            sim2 = nengo.Simulator(my_network, dt=0.01)  # Uses 0.01s dt

        Parameters
        ----------
        network : nengo.Network instance
            A network object to be built and then simulated.

        dt : float
            The length of a simulator timestep, in seconds.

        seed : int
            A seed for all stochastic operators used in this simulator.
            Note that there are not stochastic operators implemented
            currently, so this parameters does nothing.

        model : nengo.builder.Model instance or None
            A model object that contains build artifacts to be simulated.
            Usually the simulator will build this model for you; however,
            if you want to build the network manually, or to inject some
            build artifacts in the Model before building the network,
            then you can pass in an instance of ``MpiModel'' instance
            or a ``nengo.builder.Model`` instance. If the latter, it
            will be converted into an ``MpiModel''.

        partitioner:
            An instance of class Partitioner which specifies how to
            assign nengo objects to MPI processes.
        """

        # Note: seed is not used right now, but one day...
        assert seed is None, "Simulator seed not yet implemented"
        self.seed = np.random.randint(npext.maxint) if seed is None else seed

        self.n_steps = 0
        self.dt = dt

        if model is None:
            self.model = MpiModel(
                dt=dt, label="%s, dt=%f" % (network, dt),
                decoder_cache=get_default_decoder_cache())
        elif not isinstance(model, MpiModel):
            self.model = MpiModel()
            self.model.from_refimpl_model(model)

        # probe -> C++ key (int)
        self.probe_keys = {}

        # probe -> python list
        self._probe_outputs = self.model.params

        self.mpi_sim = mpi_sim.PythonMpiSimulator()

        builder.Builder.build(self.model, network)

        if partitioner is None:
            partitioner = Partitioner()

        print type(self.model)

        models = partitioner.partition(self.model, network)

        for model in models:
            mpi_chunk = self.mpi_sim.add_chunk()

            chunk.SimulatorChunk(
                mpi_chunk, model, dt, self.probe_keys, self._probe_outputs)

        self.mpi_sim.finalize()

        self.data = ProbeDict(self._probe_outputs)

    def __str__(self):
        return self.mpi_sim.to_string()

    def run_steps(self, steps):
        """Simulate for the given number of `dt` steps."""
        self.mpi_sim.run_n_steps(steps)

        for probe, probe_key in self.probe_keys.items():
            data = self.mpi_sim.get_probe_data(probe_key, np.empty)

            # logger.debug("******** PROBE DATA *********")
            # logger.debug("KEY: %s", probe_key)
            # logger.debug("PROBE: %s", probe)
            # logger.debug("DATA SHAPE: %s", str(np.array(data).shape))
            # logger.debug(data)

            if probe not in self._probe_outputs:
                self._probe_outputs[probe] = data
            else:
                self._probe_outputs[probe].extend(data)

        self.n_steps += steps

    def step(self):
        """Advance the simulator by `self.dt` seconds."""
        self.run_steps(1)

    def run(self, time_in_seconds):
        """Simulate for the given length of time."""
        steps = int(np.round(float(time_in_seconds) / self.dt))
        self.run_steps(steps)

    def trange(self, dt=None):
        dt = self.dt if dt is None else dt
        n_steps = int(self.n_steps * (self.dt / dt))
        return dt * np.arange(1, n_steps + 1)

    def reset(self):
        # TODO: clear probes in _probe_outputs
        pass
