import nengo
from nengo.connection import Connection
from nengo.ensemble import Ensemble
from nengo.node import Node
from nengo.probe import Probe
from nengo import builder
from nengo.simulator import ProbeDict
import nengo.utils.numpy as npext
from nengo.cache import NoDecoderCache, get_default_decoder_cache

import chunk
import mpi_sim

import numpy as np
import random
from collections import defaultdict

import warnings

import logging
logger = logging.getLogger(__name__)

nengo.log(debug=False, path=None)


def make_builder(base):
    """
    Create a version of an existing builder function whose only difference
    is that it uses the MpiModel to record which ops are built as part of
    building which high-level objects.
    """

    def build_object(model, obj):
        try:
            model.push_object(obj)
        except AttributeError:
            raise ValueError(
                "Must use an instance of MpiModel.")

        base(model, obj)
        model.pop_object(obj)

    return build_object


# Overwrite some of the default builder functions with functions that keep
# track of the operators that are created as part of building the objects, and
# store that information in a dictionary in the MpiModel. This information
# is used to assign operators to the correct partitions.
with warnings.catch_warnings():

    # Ignore the warning generated by overwriting the builder functions.
    warnings.simplefilter('ignore')

    builder.Builder.register(Ensemble)(
        make_builder(builder.build_ensemble))

    builder.Builder.register(Node)(
        make_builder(builder.build_node))

    builder.Builder.register(Connection)(
        make_builder(builder.build_connection))

    builder.Builder.register(Probe)(
        make_builder(builder.build_probe))


class MpiModel(builder.Model):
    """
    Output of the Builder, used by the Simulator.

    Differs from the Model in the reference implementation in that
    as the model is built, it keeps track of the object being built.
    This permits us to keep track of which operators are added as part
    of which high-level objects, so that those objects can be added
    to the correct MPI partition (recalling that the MPI partitions
    are specified in terms of the high-level nengo objects like nodes,
    networks and ensembles).
    """

    def __init__(
            self, dt=0.001, label=None, decoder_cache=NoDecoderCache()):

        self._object_context = [None]
        self.object_ops = defaultdict(list)
        super(MpiModel, self).__init__(dt, label, decoder_cache)

    def __str__(self):
        return "MpiModel: %s" % self.label

    def push_object(self, object):
        self._object_context.append(object)

    def pop_object(self, object):
        self._object_context.pop()

    def add_op(self, op):
        """
        Records that the operator was added as part of building
        the object that is on the top of _object_context stack,
        and then uses refimpl add_op to finish adding the op.
        """
        self.object_ops[self._object_context[-1]].append(op)

        logger.debug("*************************")
        logger.debug("Adding operator to model.")
        logger.debug("Operator: %s", str(op))
        logger.debug(
            "As part of nengo object: %s",
            str(self._object_context[-1]))

        super(MpiModel, self).add_op(op)

    def from_refimpl_model(self, model):
        """Create an MpiModel from an instance of a refimpl Model."""

        if not isinstance(model, builder.Model):
            raise TypeError(
                "Model must be an instance of "
                "%s." % builder.model.__name__)

        self.dt = model.dt
        self.label = model.label
        self.decoder_cache = model.decoder_cache

        self.toplevel = model.toplevel
        self.config = model.config

        self.operators = model.operators
        self.params = model.params
        self.seeds = model.seeds
        self.probes = model.probes
        self.sig = model.sig

    def partition_ops(self, network, num_partitions, partition):
        """
        Returns a list of (non-mpi) models, one for each partition,
        containing the operators designated for that partition.
        The models will have the appropriate mpi operators added in.

        Partition will not contain any information about networks.
        Only ensembles and nodes. It is a map from ensemble/nodes to
        integers giving the partition.
        """

        nodes = network.all_nodes
        nodes_in = all([node in partition for node in nodes])
        assert nodes_in, "Partition incomplete, missing nodes."

        ensembles = network.all_ensembles
        ensembles_in = all([ensemble in partition for ensemble in ensembles])
        assert ensembles_in, "Partition incomplete, missing ensembles."

        models = [builder.Model(label="Partition %d" % i)
                  for i in range(num_partitions)]

        for model in models:
            model.sig = self.sig

            model.send_signals = []
            model.recv_signals = []

        logger.debug("PARTITION:")
        logger.debug(partition)

        neuron_partition = {}

        for obj, p in partition.iteritems():

            assert isinstance(obj, Ensemble) or isinstance(obj, Node)

            if isinstance(obj, Ensemble):
                neuron_partition[obj.neurons] = p

            model = models[p]

            logger.debug("OBJECT_OPS")
            logger.debug(obj)
            logger.debug(self.object_ops[obj])

            for op in self.object_ops[obj]:
                model.add_op(op)

        partition.update(neuron_partition)

        for i, model in enumerate(models):
            logger.debug("MODEL: %g, %s", i, model.operators)

        for probe in network.all_probes:
            logger.debug("PROBE: %s", probe)

            p = partition[probe.target]
            logger.debug("partition: %s", p)
            logger.debug("probe ops: %s", self.object_ops[probe])

            for op in self.object_ops[probe]:
                models[p].add_op(op)

            models[p].probes.append(probe)
            partition[probe] = p

        connections = set(
            obj for obj in self.object_ops
            if isinstance(obj, Connection))

        connections = connections | set(network.all_connections)

        for conn in connections:
            logger.debug("CONNECTION: %s", conn)
            logger.debug("CONNECTION PRE: %s", conn.pre_obj)
            logger.debug("CONNECTION PRE TYPE: %s", type(conn.pre))
            logger.debug("CONNECTION POST: %s", conn.post_obj)
            logger.debug("CONNECTION POST TYPE: %s", type(conn.post))
            logger.debug("CONNECTION OPS: %s", self.object_ops[conn])

            pre_partition = partition[conn.pre_obj]
            post_partition = partition[conn.post_obj]

            if pre_partition == post_partition:

                model = models[pre_partition]

                for op in self.object_ops[conn]:
                    model.add_op(op)
            else:

                # This is a connection that spans partitions
                if conn.modulatory:
                    raise Exception(
                        "Connections crossing partition boundaries "
                        "must not be modulatory.")

                #if (isinstance(conn.pre_obj, Ensemble) and
                #        'synapse_out' in self.sig[conn]):

                if 'synapse_out' in self.sig[conn]:
                    signal = self.sig[conn]['synapse_out']
                else:
                    raise Exception(
                        "Connections crossing partition boundaries must "
                        "be filtered.")

                models[pre_partition].send_signals.append(
                    (signal, post_partition))

                models[post_partition].recv_signals.append(
                    (signal, pre_partition))

                pre_ops = [op for op in self.object_ops[conn]
                           if signal in op.updates]

                post_ops = filter(
                    lambda op: op not in pre_ops, self.object_ops[conn])

                for op in pre_ops:
                    models[pre_partition].add_op(op)

                for op in post_ops:
                    models[post_partition].add_op(op)

        return models


def default_partition_func(network, num_partitions, fixed_nodes=None):
    """
    Partition functions must return a dictionary which contains every
    ensemble and every node in the entire network, including subnetworks.

    Puts all nengo Nodes on partition 0.

    Pseudo-randomly assigns nengo Ensembles to remaining partitions, unless
    those an Ensemble appears as a key in fixed_nodes, in which case the
    integer that it maps to will be used as the partition for that Ensemble.

    Probably a good idea to supply your own partition in fixed_nodes.

    Parameters
    ----------
    network: the nengo network to partition

    num_partitions: number of hardware nodes to use for the simulation, and
        hence the number of partitions created by the partition function.
        If None, appropriate value chosen automatically.

    fixed_nodes: a dictionary mapping from nengo objects to indices of
        partitions/hardware nodes. Used to hard-assign nengo objects
        to specific partitions/hardware nodes.
    """

    if fixed_nodes is None:
        fixed_nodes = {}

    partition = {}
    partition.update(fixed_nodes)

    for ensemble in network.ensembles:
        if ensemble not in partition:
            if num_partitions == 1:
                partition[ensemble] = 0
            else:
                partition[ensemble] = random.choice(xrange(1, num_partitions))

    for node in network.nodes:
        if node.output is None:
            if node not in partition:
                if num_partitions == 1:
                    partition[node] = 0
                else:
                    partition[node] = random.choice(xrange(1, num_partitions))
        else:
            partition[node] = 0

    for n in network.networks:
        if n in partition:
            for ensemble in n.all_ensembles:
                partition[ensemble] = partition[n]

            for node in n.all_nodes:
                if node.output is None:
                    partition[node] = partition[n]
                else:
                    partition[node] = 0
        else:
            subnet_partition = default_partition_func(n, num_partitions)
            partition.update(subnet_partition)

    return partition


class PartitionInfo(object):
    """
    Stores info for creating MPI processes and assigns Nengo nodes to
    those processes.

    num_partitions: number of hardware nodes to use for the simulation, and
        hence the number of partitions created by the partition function.
        If None, appropriate value chosen automatically.

    fixed_nodes: a dictionary mapping from nengo objects to indices of
        partitions/hardware nodes. Used to hard-assign nengo objects
        to specific partitions/hardware nodes.

    func: a function to partition the nengo graph, assigning nengo objects
        to hardware nodes.

        Arguments:
            network
            num_partitions
            fixed_nodes

    args: extra positional args passed to func

    kwargs: extra keyword args passed to func
    """

    def __init__(self, num_partitions=None, func=None,
                 fixed_nodes=None, *args, **kwargs):

        if num_partitions is None:
            self.num_partitions = 1

            if func is not None:
                # issue a warning that its being ignored
                pass

            if fixed_nodes is not None:
                # issue a warning that its being ignored
                pass

            self.func = default_partition_func
            self.fixed_nodes = {}

        else:
            self.num_partitions = num_partitions

            if func is None:
                func = default_partition_func

            self.func = func

            if fixed_nodes is None:
                fixed_nodes = {}

            self.fixed_nodes = fixed_nodes

        self.args = args
        self.kwargs = kwargs

    def partition(self, network):
        return self.func(
            network, self.num_partitions, self.fixed_nodes,
            *self.args, **self.kwargs)


class Simulator(object):
    """MPI simulator for nengo 2.0."""

    def __init__(
            self, network, dt=0.001, seed=None, model=None,
            partition_info=None):
        """
        Most of the time, you will pass in a network and sometimes a dt::

            sim1 = nengo.Simulator(my_network)  # Uses default 0.001s dt
            sim2 = nengo.Simulator(my_network, dt=0.01)  # Uses 0.01s dt

        Parameters
        ----------
        network : nengo.Network instance
            A network object to be built and then simulated.

        dt : float
            The length of a simulator timestep, in seconds.

        seed : int
            A seed for all stochastic operators used in this simulator.
            Note that there are not stochastic operators implemented
            currently, so this parameters does nothing.

        model : nengo.builder.Model instance or None
            A model object that contains build artifacts to be simulated.
            Usually the simulator will build this model for you; however,
            if you want to build the network manually, or to inject some
            build artifacts in the Model before building the network,
            then you can pass in an instance of ``MpiModel'' instance
            or a ``nengo.builder.Model`` instance. If the latter, it
            will be converted into an ``MpiModel''.

        partition_info:
            An instance of PartitionInfo storing information specifying
            how nodes are assigned to MPI processes.
        """

        # Note: seed is not used right now, but one day...
        assert seed is None, "Simulator seed not yet implemented"
        self.seed = np.random.randint(npext.maxint) if seed is None else seed

        self.n_steps = 0
        self.dt = dt

        if model is None:
            self.model = MpiModel(
                dt=dt, label="%s, dt=%f" % (network, dt),
                decoder_cache=get_default_decoder_cache())

        elif not isinstance(model, MpiModel):
            self.model = MpiModel()
            self.model.from_refimpl_model(model)

        # probe -> C++ key (int)
        self.probe_keys = {}

        # probe -> python list
        self._probe_outputs = self.model.params

        self.mpi_sim = mpi_sim.PythonMpiSimulator()

        builder.Builder.build(self.model, network)

        if partition_info is None:
            partition_info = PartitionInfo()

        num_partitions = partition_info.num_partitions
        partition = partition_info.partition(network)

        models = self.model.partition_ops(
            network, num_partitions, partition)

        for model in models:
            mpi_chunk = self.mpi_sim.add_chunk()

            chunk.SimulatorChunk(
                mpi_chunk, model, dt, self.probe_keys, self._probe_outputs)

        self.mpi_sim.finalize()

        self.data = ProbeDict(self._probe_outputs)

    def __str__(self):
        return self.mpi_sim.to_string()

    def run_steps(self, steps):
        """Simulate for the given number of `dt` steps."""
        self.mpi_sim.run_n_steps(steps)

        for probe, probe_key in self.probe_keys.items():
            data = self.mpi_sim.get_probe_data(probe_key, np.empty)

            logger.debug("******** PROBE DATA *********")
            logger.debug("KEY: %s", probe_key)
            logger.debug("PROBE: %s", probe)
            logger.debug("DATA SHAPE: %s", str(np.array(data).shape))

            if probe not in self._probe_outputs:
                self._probe_outputs[probe] = data
            else:
                self._probe_outputs[probe].extend(data)

        self.n_steps += steps

    def step(self):
        """Advance the simulator by `self.dt` seconds."""
        self.run_steps(1)

    def run(self, time_in_seconds):
        """Simulate for the given length of time."""
        steps = int(np.round(float(time_in_seconds) / self.dt))
        self.run_steps(steps)

    def trange(self, dt=None):
        dt = self.dt if dt is None else dt
        n_steps = int(self.n_steps * (self.dt / dt))
        return dt * np.arange(1, n_steps + 1)

    def reset(self):
        # TODO: clear probes in _probe_outputs
        pass
